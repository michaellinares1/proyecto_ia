# -*- coding: utf-8 -*-
"""AVANZE_PROYECTO_IA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-NnIt_7g1E-rLW27XX5qHcPKqMRbCmhz
"""

#importe de las bibliotecas
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns  # Mejores gráficas con respecto a plt
#implementar el dataset
file_path = 'DATASET_DEUDA_POR_COBRAR_PRINCIPALES_TRIBUTOS_MUNICIPALES_MPPAITA_2022_2023.csv'
dataset = pd.read_csv(file_path, encoding='latin1')

#Vemos los valores nulos
dataset.isnull().sum()

dataset.columns

#QUITAMOS FECHA_CORTE Y BORRAR
dataset = dataset.drop(columns=['FECHA_CORTE'])
dataset = dataset.drop(columns=['DEPARTAMENTO'])
dataset = dataset.drop(columns=['DISTRITO'])
dataset = dataset.drop(columns=['PROVINCIA'])
dataset = dataset.drop(columns=['SECTOR_UBICACION'])
dataset = dataset.drop(columns=['NOM_CONTRIBUYENTE'])
dataset = dataset.drop(columns=['GOBIERNO_LOCAL'])
dataset = dataset.drop(columns=['UBICACION_PREDIO'])
dataset.isnull().sum()

#QUITAMOS VALORES NULOS
dataset = dataset.dropna()
dataset.isnull().sum()

#cuantas columnas y el tipo de columnas que se tiene
dataset.info()

#numero de elementos, media de las columnas, desviacion tipica , precio minimo, precio maximo, cuartiles
dataset.describe()

#conocer los valores de las columnas , su nombre
dataset.columns

import matplotlib.pyplot as plt
import seaborn as sns

# Establecer el tamaño de la figura
plt.figure(figsize=(12, 6))

# Configurar el tamaño de las etiquetas en el eje x
plt.xticks(fontsize=8)

# Crear el gráfico de barras
ax = sns.countplot(x="COD_TRIBUTO", data=dataset)

# Añadir etiquetas y contador en cada barra
for p in ax.patches:
    ax.annotate(f'{p.get_height()}', (p.get_x() + p.get_width() / 2., p.get_height()),
                ha='center', va='center', fontsize=8, color='black', xytext=(0, 5),
                textcoords='offset points')

# Añadir etiquetas al eje x y y
plt.xlabel('Código de Tributo', fontsize=12)
plt.ylabel('Conteo', fontsize=12)

# Añadir título al gráfico
plt.title('Conteo por Código de Tributo', fontsize=16)


# Mostrar el gráfico
plt.show()

# Calcular los promedios por año
promedios_por_año = dataset.groupby('ANIO_DEUDA')['IMPORTE_CALCULADO'].mean().reset_index()

# Establecer el tamaño de la figura
plt.figure(figsize=(12, 6))

# Crear el gráfico de barras del promedio de COSTO por AÑO
barplot = sns.barplot(x="ANIO_DEUDA", y="IMPORTE_CALCULADO", data=promedios_por_año)

# Añadir etiquetas al eje x y y
plt.xlabel('Año', fontsize=12)
plt.ylabel('Promedio de Importe Calculado', fontsize=12)

# Añadir título al gráfico
plt.title('Promedio de importe calculado por Año', fontsize=16)

# Agregar cantidades en las barras
for index, value in enumerate(promedios_por_año['IMPORTE_CALCULADO']):
    barplot.text(index, value + 0.1, round(value, 2), ha='center', va='bottom', fontsize=10)

# Mostrar el gráfico
plt.show()

from sklearn.model_selection import train_test_split
dataset.columns

# Assign the correct columns to X and Y.
X = dataset[['ANIO_DEUDA']]
Y = dataset['IMPORTE_DEUDA']
X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.3, random_state=42)
X_train

import numpy as np
from sklearn.linear_model import LassoLars
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error

lasso_lars = LassoLars()

lasso_lars.fit(X_train, Y_train)

from sklearn import metrics
predicciones = lasso_lars.predict(X_test)
predicciones

coeficientes = lasso_lars.coef_
print("Coeficientes del modelo:", coeficientes)

y_pred_lasso = lasso_lars.predict(X_test)

plt.scatter(X_test, Y_test, color='blue', label='Datos reales')
plt.plot(X_test, y_pred_lasso, color='red', linewidth=2, label='Predicción Lasso LARS')
plt.xlabel('X')
plt.ylabel('y')
plt.title('Regresión Lasso LARS')

import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import BayesianRidge
from sklearn.metrics import mean_squared_error, r2_score

BR = BayesianRidge()
BR.fit(X_train, Y_train)

y_pred = BR.predict(X_test)
mse = mean_squared_error(Y_test, y_pred)
r2 = r2_score(Y_test, y_pred)

print(f"Mean Squared Error: {mse}")

print(f"R-squared: {r2}")

coef = BR.coef_
coef

import matplotlib.pyplot as plt

# Suponiendo que X_test, Y_test, y y_pred ya están definidos
plt.scatter(X_test, Y_test, color="black", label="Datos de prueba")
plt.plot(X_test, y_pred, color="blue", linewidth=3, label="Predicción")

plt.title("Gráfico de Predicción vs Datos de Prueba")
plt.xlabel("X Test")
plt.ylabel("Y Test / Predicción")
plt.legend()

plt.xticks(())
plt.yticks(())

plt.show()


import numpy as np
import pandas as pd
import statsmodels.api as sm
import statsmodels.formula.api as smf
import matplotlib.pyplot as plt

data = pd.concat([X, Y], axis=1)

# Definir el modelo para el percentil 0.5 (mediana)
quantile = 0.5
model = smf.quantreg('IMPORTE_DEUDA ~ ANIO_DEUDA', data)
res = model.fit(q=quantile)

# Resumen del modelo
print(res.summary())

# Predicciones
x_pred = np.linspace(data['ANIO_DEUDA'].min(), data['ANIO_DEUDA'].max(), 100)
y_pred = res.predict(pd.DataFrame({'ANIO_DEUDA': x_pred}))

# Gráfico
plt.scatter(data['ANIO_DEUDA'], data['IMPORTE_DEUDA'], alpha=0.5, label='Datos')
plt.plot(x_pred, y_pred, color='red', label=f'Quantile {quantile}')
plt.xlabel('ANIO_DEUDA')
plt.ylabel('IMPORTE_DEUDA')
plt.legend()
plt.show()